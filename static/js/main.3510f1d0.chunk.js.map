{"version":3,"sources":["MyPathVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/bfs.js","algorithms/dfs.js","algorithms/astar.js","algorithms/bestFirst.js","MyPathVisualizer/grid.jsx","components/weight.jsx","components/navbar.jsx","components/footer.jsx","MyPathVisualizer/MyPathVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","col","isFinish","isStart","isWall","weight","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","unvistedNeighbors","neighbors","filter","getUnvisitedNeighbors","neighbor","parseInt","previousNode","sort","nodeA","nodeB","bfs","queue","nextNode","updateVisitedNodesInOrder","unvisitedNeighbors","updateVisitedNodes","dfs","stack","unshift","astar","heurisitcDistance","manhattanDistance","sortNodesByHeurisitic","Math","abs","bestFirst","getInitialGrid","currentRow","createNode","getNewGridWithWallToggled","newGrid","slice","newNode","getNewGridWithWeightToggled","weightSelected","newWeight","Weights","sendWeight","parentCallback","handleChange","bind","document","getElementById","style","backgroundColor","event","value","target","setState","ids","for","name","type","onChange","checked","Header","class","onClick","forDijkstra","disabled","forDisabled","forBfs","forDfs","forAstar","forBest","forReset","forResetting","forWallWeight","Footer","MyPathVisualizer","callbackFunction","weightSelect","mouseIsPressed","visualizing","reseting","console","log","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","visitedCss","setProperty","shortestCss","algo","currentNode","getNodesInShortestPathOrder","animate","visualize","reset","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","rel","href","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3510f1d0.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.scss\";\n\nexport default class Node extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {};\n\t}\n\n\n\trender() {\n\t\tconst {\n\t\t\tcol,\n\t\t\tisFinish,\n\t\t\tisStart,\n\t\t\tisWall,\n\t\t\tweight,\n\t\t\tonMouseDown,\n\t\t\tonMouseEnter,\n\t\t\tonMouseUp,\n\t\t\trow,\n\t\t} = this.props;\n\n\t\tconst color = weight===\"\"\n\t\t\t\t?\"\"\n\t\t\t\t:weight===\"5\"\n\t\t\t\t?\"red\"\n\t\t\t\t:weight===\"25\"\n\t\t\t\t?\"blue\"\n\t\t\t\t:weight===\"100\"\n\t\t\t\t?\"green\"\n\t\t\t\t:\"\"\n\t\tconst extraClassName = isFinish\n\t\t\t? \"nodefinish\"\n\t\t\t: isStart\n\t\t\t? \"nodestart\"\n\t\t\t: isWall\n\t\t\t? \"nodewall\"\n\t\t\t: weight!==\"\"\n\t\t\t? \"node\"+\" \"+color\n\t\t\t: \"node\"\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tid={`node-${row}-${col}`}\n\t\t\t\tclassName={`${extraClassName}`}\n\t\t\t\tonMouseDown={() => onMouseDown(row, col)}\n\t\t\t\tonMouseEnter={() => onMouseEnter(row, col)}\n\t\t\t\tonMouseUp={() => onMouseUp()}\n\t\t\t>\n\t\t\t</div>\n\t\t);\n\t}\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\nexport function dijkstra(grid, startNode, finishNode) {\n\tif (!startNode || !finishNode || startNode === finishNode) return false;\n\n\tstartNode.distance = 0;\n\tconst visitedNodesInOrder = [];\n\tconst unvisitedNodes = getAllNodes(grid);\n\n\twhile (unvisitedNodes.length) {\n\t\tsortNodesByDistance(unvisitedNodes);\n\n\t\tconst closestNode = unvisitedNodes.shift();\n\n\t\tif (closestNode.isWall) continue;\n\n\t\tif (closestNode.distance === Infinity) return visitedNodesInOrder;\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\n\t}\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\tconst unvistedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvistedNeighbors) {\n\t\tif(node.weight===\"\")\n\t\t\tneighbor.distance = node.distance + 1;\n\t\telse\n\t\t\tneighbor.distance = node.distance + parseInt(node.weight);\n\t\tneighbor.previousNode = node;\n\t}\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst { row, col } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter(neighbors => !neighbors.isVisited);\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","// Performs BFS's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\n\nexport function bfs(grid, startNode, finishNode) {\n\tif (!startNode || !finishNode || startNode === finishNode) {\n\t\treturn false;\n\t}\n\n\tconst queue = [];\n\tconst visitedNodesInOrder = [];\n\tstartNode.isVisited = true;\n\tqueue.push(startNode);\n\twhile (queue.length) {\n\t\tconst nextNode = queue.shift();\n\n\t\tif (nextNode.isWall) continue;\n\n\t\t//nextNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(nextNode);\n\n\t\tif (nextNode === finishNode) return visitedNodesInOrder;\n\n\t\tupdateVisitedNodesInOrder(nextNode, queue, grid);\n\t}\n}\n\nfunction updateVisitedNodesInOrder(nextNode, queue, grid) {\n\tconst unvisitedNeighbors = updateVisitedNodes(nextNode, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tneighbor.isVisited = true;\n\t\tneighbor.previousNode = nextNode;\n\t\tqueue.push(neighbor);\n\t}\n}\n\nfunction updateVisitedNodes(nextNode, grid) {\n\tconst neighbors = [];\n\tconst { row, col } = nextNode;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter(neighbors => !neighbors.isVisited);\n}\n\nexport function getNodesInShortestPathOrderBfs(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","// Performs DFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\n\nexport function dfs(grid, startNode, finishNode) {\n\tif (!startNode || !finishNode || startNode === finishNode) return false;\n\n\tconst stack = [];\n\tconst visitedNodesInOrder = [];\n\tstack.push(startNode);\n\n\twhile (stack.length) {\n\t\tconst nextNode = stack.shift();\n\n\t\tif (nextNode.isWall) continue;\n\n\t\tnextNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(nextNode);\n\n\t\tif (nextNode === finishNode) return visitedNodesInOrder;\n\n\t\tupdateVisitedNodesInOrder(nextNode, stack, grid);\n\t}\n}\n\nfunction updateVisitedNodesInOrder(nextNode, stack, grid) {\n\tconst unvisitedNeighbors = updateVisitedNodes(nextNode, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tneighbor.previousNode = nextNode;\n\t\tstack.unshift(neighbor);\n\t}\n}\n\nfunction updateVisitedNodes(nextNode, grid) {\n\tconst neighbors = [];\n\tconst { row, col } = nextNode;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter(neighbors => !neighbors.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDfs(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","// Performs A* algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\nexport function astar(grid, startNode, finishNode) {\n\tif (!startNode || !finishNode || startNode === finishNode) {\n\t\treturn false;\n\t}\n\n\tstartNode.distance = 0;\n\tstartNode.heurisitcDistance = manhattanDistance(startNode, finishNode);\n\tconst visitedNodesInOrder = [];\n\tconst unvisitedNodes = getAllNodes(grid);\n\n\twhile (unvisitedNodes.length) {\n\t\tsortNodesByHeurisitic(unvisitedNodes);\n\t\tconst closestNode = unvisitedNodes.shift();\n\t\t//console.log(closestNode);\n\t\tif (closestNode.isWall) continue;\n\n\t\tif (closestNode.heurisitcDistance === Infinity)\n\t\t\treturn visitedNodesInOrder;\n\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\t\tupdateUnvisitedNeighbors(closestNode, grid, finishNode);\n\t}\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\n\t\tif(node.weight===\"\")\n\t\t\tneighbor.distance = node.distance + 1;\n\t\telse\n\t\t\tneighbor.distance = node.distance + parseInt(node.weight);\n\t\t\n\t\t//update heurisitcDistance\n\t\tif (\n\t\t\tneighbor.heurisitcDistance >\n\t\t\tneighbor.distance + manhattanDistance(neighbor, finishNode)\n\t\t) {\n\t\t\t//console.log(neighbor);\n\t\t\tneighbor.heurisitcDistance =\n\t\t\t\tneighbor.distance + manhattanDistance(neighbor, finishNode);\n\t\t\tneighbor.previousNode = node;\n\t\t}\n\t}\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst { row, col } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter(neighbors => !neighbors.isVisited);\n}\n\nfunction sortNodesByHeurisitic(unvisitedNodes) {\n\tunvisitedNodes.sort(\n\t\t(nodeA, nodeB) => nodeA.heurisitcDistance - nodeB.heurisitcDistance\n\t);\n}\n\nfunction manhattanDistance(nodeA, nodeB) {\n\treturn Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\n}\n\nexport function getNodesInShortestPathOrderAstar(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","// Performs Best first search algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\n//In best first search algorithm only the heuristic distance is considered,not the distance to that node.\n\nexport function bestFirst(grid, startNode, finishNode) {\n\tif (!startNode || !finishNode || startNode === finishNode) return false;\n\n\tstartNode.distance = 0;\n\tstartNode.heurisitcDistance = manhattanDistance(startNode, finishNode);\n\n\tconst visitedNodesInOrder = [];\n\tconst unvisitedNodes = getAllNodes(grid);\n\n\twhile (unvisitedNodes.length) {\n\t\tsortNodesByHeurisitic(unvisitedNodes);\n\t\tconst closestNode = unvisitedNodes.shift();\n\n\t\tif (closestNode.isWall) continue;\n\n\t\tif (closestNode.heurisitcDistance === Infinity)\n\t\t\treturn visitedNodesInOrder;\n\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\n\t\tupdateUnvisitedNeighbors(closestNode, grid, finishNode);\n\t}\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tif(node.weight===\"\")\n\t\t\tneighbor.distance = node.distance + 1;\n\t\telse\n\t\t\tneighbor.distance = node.distance + parseInt(node.weight);\n\t\t//update heurisitcDistance\n\t\tif (\n\t\t\tneighbor.heurisitcDistance > manhattanDistance(neighbor, finishNode)\n\t\t) {\n\t\t\tneighbor.heurisitcDistance = manhattanDistance(\n\t\t\t\tneighbor,\n\t\t\t\tfinishNode\n\t\t\t);\n\t\t\tneighbor.previousNode = node;\n\t\t}\n\t}\n}\n\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\tconst neighbors = [];\n\tconst { row, col } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\treturn neighbors.filter(neighbors => !neighbors.isVisited);\n}\n\nfunction sortNodesByHeurisitic(unvisitedNodes) {\n\tunvisitedNodes.sort(\n\t\t(nodeA, nodeB) => nodeA.heurisitcDistance - nodeB.heurisitcDistance\n\t);\n}\n\nfunction manhattanDistance(nodeA, nodeB) {\n\treturn Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\n}\n\nexport function getNodesInShortestPathOrderBest(finishNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","const START_NODE_ROW = 5;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 25;\n\nexport const getInitialGrid = () => {\n\tconst grid = [];\n\tfor (let row = 0; row < 15; row++) {\n\t\tconst currentRow = [];\n\t\tfor (let col = 0; col < 42; col++) {\n\t\t\tcurrentRow.push(createNode(col, row));\n\t\t}\n\t\tgrid.push(currentRow);\n\t}\n\treturn grid;\n}\n\nconst createNode = (col, row) => {\n\treturn {\n\t\tcol,\n\t\trow,\n\t\tisStart: row === START_NODE_ROW && col === START_NODE_COL,\n\t\tisFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n\t\tdistance: Infinity,\n\t\theurisitcDistance: Infinity,\n\t\tisVisited: false,\n\t\tisWall: false,\n\t\tweight: \"\",\n\t\tpreviousNode: null\n\t}\n}\n\nexport const getNewGridWithWallToggled = (grid, row, col) => {\n\tconst newGrid = grid.slice();\n\tconst node = newGrid[row][col];\n\tconst newNode = {\n\t\t...node,\n\t\tisWall: !node.isWall\n\t};\n\tnewGrid[row][col] = newNode;\n\treturn newGrid;\n}\n\nexport const getNewGridWithWeightToggled = (grid, row, col, weightSelected) => {\n\tconst newGrid = grid.slice();\n\tconst node = newGrid[row][col];\n\tconst previousWeight = node.weight;\n\n\tlet newWeight = \"\";\n\n\tif(previousWeight!==weightSelected)\n\t\tnewWeight = weightSelected;\n\n\tconst newNode = {\n\t\t...node,\n\t\tweight: newWeight,\n\t\tisWall: false,\n\t};\n\tnewGrid[row][col] = newNode;\n\treturn newGrid;\n}","import React, { Component } from \"react\";\nimport \"./weight.css\"\n\nclass Weights extends Component{\n\tconstructor(props){\n\t\tsuper(props)\n\t\tthis.state={\n\t\t\tweight: \"\",\n\t\t}\n\t\tthis.handleChange = this.handleChange.bind(this)\n\t}\n\t\n\tsendWeight = () =>{\n\t\tthis.props.parentCallback(this.state.weight)\n\t}\n\n    componentDidMount() {\n        document.getElementById(\"forWall\").style.backgroundColor = \"yellow\";\n\t}\n\n\thandleChange(event){\n\t\tconst {value} = event.target\n\t\tthis.setState(\n\t\t\t{weight:value},\n\t\t\t()=>{this.sendWeight()\n\t\t})\n\t\tdocument.getElementById(\"for5\").style.backgroundColor = \"\";\n\t\tdocument.getElementById(\"for25\").style.backgroundColor = \"\";\n\t\tdocument.getElementById(\"for100\").style.backgroundColor = \"\";\n\t\tdocument.getElementById(\"forWall\").style.backgroundColor = \"\";\n\t\tlet ids = \"\"\n\t\tif(value===\"\")\n\t\t\tids = \"forWall\"\n\t\telse\t\n\t\t\tids = \"for\"+value\n\t\tdocument.getElementById(ids).style.backgroundColor = \"yellow\";\n\t}\n\n\trender(){\n\t\treturn(\n\t\t\t<div id=\"radios\">\n\t\t\t\t<label for=\"input1\" id=\"for5\"></label>\n\t\t\t\t<input  id=\"input1\" name=\"weight\" type=\"radio\" value=\"5\" onChange={this.handleChange} checked={this.state.weight === \"5\"}/>\n\t\t\t\t<label for=\"input2\" id=\"for25\"></label>\n\t\t\t\t<input  id=\"input2\" name=\"weight\" type=\"radio\" value=\"25\" onChange={this.handleChange} checked={this.state.weight === \"25\"}/>\n\t\t\t\t<label for=\"input3\" id=\"for100\"></label>\n\t\t\t\t<input  id=\"input3\" name=\"weight\" type=\"radio\" value=\"100\" onChange={this.handleChange} checked={this.state.weight === \"100\"}/>\n\t\t\t\t<label for=\"input4\" id=\"forWall\"></label>\n\t\t\t\t<input  id=\"input4\" name=\"weight\" type=\"radio\" value=\"\" onChange={this.handleChange} checked={this.state.weight === \"\"}/>\n\t\t\t\t<span id=\"slider\"></span>\n            </div>\n\t\t)\n\t}\n}\n\nexport default Weights;","import React from \"react\";\nimport Weights from \"./weight.jsx\"\nimport \"./navbar.css\"\n\n\nfunction Header(props){\n\treturn (\n\t\t<header className=\"top-bar\">\n\t\t\t<div class=\"plate\">\n\t\t\t  <p class=\"script\"><span>Pathfinding</span></p>\n\t\t\t  <p class=\"script\"><span>Algorithms</span></p>\n\t\t\t</div>\n\t\t\t<button onClick={props.forDijkstra} disabled={props.forDisabled} class=\"button\" id=\"button-2\">\n\t\t\t\t<div id=\"slide\"></div>\n\t\t\t\t<a>DIJKSTRA</a>\n\t\t\t</button>\n\t\t\t<button onClick={props.forBfs} disabled={props.forDisabled} class=\"button\" id=\"button-2\">\n\t\t\t\t<div id=\"slide\"></div>\n\t\t\t\t<a>BFS</a>\n\t\t\t</button>\n\t\t\t<button onClick={props.forDfs} disabled={props.forDisabled} class=\"button\" id=\"button-2\">\n\t\t\t\t<div id=\"slide\"></div>\n\t\t\t\t<a>DFS</a>\n\t\t\t</button>\n\t\t\t<button onClick={props.forAstar} disabled={props.forDisabled} class=\"button\" id=\"button-2\">\n\t\t\t\t<div id=\"slide\"></div>\n\t\t\t\t<a>A-STAR</a>\n\t\t\t</button>\n\t\t\t<button onClick={props.forBest} disabled={props.forDisabled} class=\"button\" id=\"button-2\">\n\t\t\t\t<div id=\"slide\"></div>\n\t\t\t\t<a>BEST-FIRST</a>\n\t\t\t</button>\n\t\t\t<button onClick={props.forReset} disabled={props.forResetting} class=\"button\" id=\"button-2\">\n\t\t\t\t<div id=\"slide\"></div>\n\t\t\t\t<a>RESET</a>\n\t\t\t</button>\n\t\t\t<Weights parentCallback = {props.forWallWeight}/>\n\t\t</header>\n\t)\n}\n\nexport default Header","import React from \"react\";\nimport \"./footer.css\"\n\nfunction Footer(){\n\treturn(\n\t\t<div class=\"footer\">\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p class=\"footer-text\">Start Node</p>\n\t\t\t\t<div class=\"image-contain start\"/>\n\t\t\t</div>\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p class=\"footer-text\">End Node</p>\n\t\t\t\t<span class=\"image-contain end\"></span>\n\t\t\t</div>\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p class=\"footer-text\">Unvisited Node</p>\n\t\t\t\t<span class=\"image-contain unvisited\"></span>\n\t\t\t</div>\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p class=\"footer-text\">Visited Nodes</p>\n\t\t\t\t<span class=\"image-contain visited\"></span>\n\t\t\t</div>\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p class=\"footer-text\">Current Node</p>\n\t\t\t\t<span class=\"image-contain current\"></span>\n\t\t\t</div>\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p class=\"footer-text\">Path Node</p>\n\t\t\t\t<span class=\"image-contain path\"></span>\n\t\t\t</div>\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p class=\"footer-text\">Wall node</p>\n\t\t\t\t<span class=\"image-contain wall\"></span>\n\t\t\t</div>\n\t\t\t<div class=\"container-info\">\n\t\t\t\t<p>Weighted Nodes</p>\n\t\t\t\t<span class=\"image-contain weighted5\"></span>\n\t\t\t\t<span class=\"image-contain weighted25\"></span>\n\t\t\t\t<span class=\"image-contain weighted100\"></span>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\nexport default Footer","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\nimport { bfs } from \"../algorithms/bfs\";\nimport { dfs } from \"../algorithms/dfs\";\nimport { astar } from \"../algorithms/astar\";\nimport {\n\tbestFirst\n} from \"../algorithms/bestFirst\";\n//import { pso } from \"../algorithms/pso\";\n\nimport \"./MyPathVisualizer.css\";\nimport {getInitialGrid, getNewGridWithWallToggled, getNewGridWithWeightToggled} from \"./grid.jsx\"\nimport Weights from \"../components/weight.jsx\"\nimport Header from \"../components/navbar.jsx\"\nimport Footer from \"../components/footer.jsx\"\n\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 25;\n\nexport default class MyPathVisualizer extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tgrid: [],\n\t\t\tmouseIsPressed: false,\n\t\t\tvisualizing: false,\n\t\t\treseting: false,\n\t\t\tweightSelect: \"\"\n\t\t};\n\t}\n\n\tcomponentDidMount() {\n\t\tconst grid = getInitialGrid();\n\t\tthis.setState({ grid:grid });\n\t}\n\n\thandleMouseDown(row, col) {\n\t\tlet newGrid;\n\t\tconsole.log(\"Weight selected\",this.state.weightSelect)\t\n\t\tif(this.state.weightSelect===\"\")\n\t\t\tnewGrid = getNewGridWithWallToggled(this.state.grid,row,col)\n\t\telse\t\t\t\n\t\t\tnewGrid = getNewGridWithWeightToggled(this.state.grid, row, col,this.state.weightSelect);\n\t\tthis.setState({ grid: newGrid, mouseIsPressed: true , weightSelect: this.state.weightSelect});\n\t}\n\n\thandleMouseEnter(row, col) {\n\t\tif (!this.state.mouseIsPressed) return;\n\n\t\tlet newGrid;\n\t\tif(this.state.weightSelect===\"\")\n\t\t\tnewGrid = getNewGridWithWallToggled(this.state.grid,row,col)\n\t\telse\n\t\t\tnewGrid = getNewGridWithWeightToggled(this.state.grid, row, col,this.state.weightSelect);\n\t\tthis.setState({ grid: newGrid, weightSelect: this.state.weightSelect});\n\t}\n\n\thandleMouseUp() {\n\t\tthis.setState({ mouseIsPressed: false });\n\t}\n\n\tanimate(visitedNodesInOrder, nodesInShortestPathOrder) {\n\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\tif(i===0)\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tif (i === visitedNodesInOrder.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.animateShortestPath(nodesInShortestPathOrder);\n\t\t\t\t}, 50 * i);\n\t\t\t\t\n\t\t\t\tsetTimeout(()=>{\n\t\t\t\t\tthis.setState({reseting:false})\n\t\t\t\t},55*i);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(node.row===FINISH_NODE_ROW && node.col===FINISH_NODE_COL)\n\t\t\t\tcontinue\n\n\t\t\tconst weight = node.weight;\n\t\t\tlet visitedCss = \"\"\n\n\t\t\tvisitedCss = weight===\"5\"\n\t\t\t\t?\"node node-visited red\"\n\t\t\t\t:weight===\"25\"\n\t\t\t\t?\"node node-visited blue\"\n\t\t\t\t:weight===\"100\"\n\t\t\t\t?\"node node-visited green\"\n\t\t\t\t:\"node node-visited otherwise\"\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(\n\t\t\t\t\t`node-${node.row}-${node.col}`\n\t\t\t\t).className = visitedCss;\n\t\t\t\tdocument.getElementById(\n\t\t\t\t\t`node-${node.row}-${node.col}`\n\t\t\t\t).style.setProperty('--v',visitedCss)\n\t\t\t}, 50 * i);\n\t\t}\n\n\t}\n\n\tanimateShortestPath(nodesInShortestPathOrder) {\n\t\tfor (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n\t\t\tconst node = nodesInShortestPathOrder[i];\n\t\t\tif(node.row===START_NODE_ROW && node.col===START_NODE_COL)\n\t\t\t\tcontinue\n\t\t\tif(node.row===FINISH_NODE_ROW && node.col===FINISH_NODE_COL)\n\t\t\t\tcontinue\n\n\t\t\tlet shortestCss = \"\"\n\t\t\tconst weight = node.weight\n\t\t\tshortestCss = weight===\"5\"\n\t\t\t\t?\"node node-shortest-path final red\"\n\t\t\t\t:weight===\"25\"\n\t\t\t\t?\"node node-shortest-path final blue\"\n\t\t\t\t:weight===\"100\"\n\t\t\t\t?\"node node-shortest-path final green\"\n\t\t\t\t:\"node node-shortest-path final otherwise-visited\"\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(\n\t\t\t\t\t`node-${node.row}-${node.col}`\n\t\t\t\t).className = shortestCss;\n\t\t\t\tdocument.getElementById(\n\t\t\t\t\t`node-${node.row}-${node.col}`\n\t\t\t\t).style.setProperty('--c',shortestCss)\n\t\t\t}, 50 * i);\n\t\t}\n\t}\n\n\tvisualize(algo){\n\t\tconst {grid} = this.state;\n\t\tthis.setState({visualizing:true,reseting:true})\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COL];\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\t\tconst visitedNodesInOrder = algo(grid,startNode,finishNode);\n\t\tconst nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\t\tthis.animate(visitedNodesInOrder,nodesInShortestPathOrder);\n\t\t//this.setState({visualizing:false})\n\t\t// this.reset();\n\t}\n\n\treset(){\n\t\tconst newGrid = getInitialGrid();\n\n\t\tfor (let row = 0; row < 15; row++) {\n\t\t\tfor (let col = 0; col < 40; col++) {\n\t\t\t\tif(row===START_NODE_ROW && col===START_NODE_COL)\n\t\t\t\t\tcontinue\n\t\t\t\tif(row===FINISH_NODE_ROW && col===FINISH_NODE_COL)\n\t\t\t\t\tcontinue\n\t\t\t\tdocument.getElementById(`node-${newGrid[row][col].row}-${newGrid[row][col].col}`).className = \"node\";\n\t\t\t}\n\t\t}\n\n\t\tthis.setState({grid:newGrid,visualizing:false})\n\t}\n\n\t// Callback function to get weight from selected weights.\n\tcallbackFunction = (weight) =>{\n\t\tthis.setState({weightSelect:weight})\n\t}\n\n\n\n\trender() {\n\t\tconst { grid, mouseIsPressed } = this.state;\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<Header \n\t\t\t\t\tforDijkstra={()=>this.visualize(dijkstra)}\n\t\t\t\t\tforBfs={()=>this.visualize(bfs)}\n\t\t\t\t\tforDfs={()=>this.visualize(dfs)}\n\t\t\t\t\tforAstar={()=>this.visualize(astar)}\n\t\t\t\t\tforBest={()=>this.visualize(bestFirst)}\n\t\t\t\t\tforReset={()=>this.reset()}\n\t\t\t\t\tforDisabled={this.state.visualizing}\n\t\t\t\t\tforResetting={this.state.reseting}\n\t\t\t\t\tforWallWeight={this.callbackFunction}\n\t\t\t\t/>\n\t\t\t\t<div className=\"grid\">\n\t\t\t\t\t{grid.map((row, rowIdx) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={rowIdx}>\n\t\t\t\t\t\t\t\t{row.map((node, nodeIdx) => {\n\t\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t\t\t\tisFinish,\n\t\t\t\t\t\t\t\t\t\tweight,\n\t\t\t\t\t\t\t\t\t\tisStart,\n\t\t\t\t\t\t\t\t\t\tisWall\n\t\t\t\t\t\t\t\t\t} = node;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIdx}\n\t\t\t\t\t\t\t\t\t\t\tcol={col}\n\t\t\t\t\t\t\t\t\t\t\tisFinish={isFinish}\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t\t\t\t\tweight={weight}\n\t\t\t\t\t\t\t\t\t\t\tmouseIsPressed={mouseIsPressed}\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, col) =>\n\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseDown(row, col)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) =>\n\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseEnter(row, col)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() =>\n\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseUp()\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t\t<div> Created By <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/Kaustubh1Verma/\">Kaustubh Verma</a></div>\n\t\t\t\t<Footer/>\n\t\t\t</>\n\t\t)\n\t}\n\n}\n","import React from 'react';\n\nimport MyPathVisualizer from './MyPathVisualizer/MyPathVisualizer';\n\nimport './App.css';   \n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MyPathVisualizer></MyPathVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}